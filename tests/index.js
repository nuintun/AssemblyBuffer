/**
 * @module Buffer
 * @license MIT
 * @version 0.0.1
 * @author nuintun
 * @description A buffer tool using WebAssembly.
 * @see https://github.com/nuintun/AssemblyBuffer#readme
 */

'use strict';

/**
 * @module hex
 */
/**
 * @type {string[]}
 * @description 已获得的 hex 映射表
 */
var mapping = [];
// 字母映射表
var alphabet = '0123456789ABCDEF';
// 生成映射表
for (var i = 0; i < 16; ++i) {
    var i16 = i * 16;
    for (var j = 0; j < 16; ++j) {
        mapping[i16 + j] = alphabet[i] + alphabet[j];
    }
}
/**
 * @function zero
 * @description 数字左边补零操作
 * @param {number} value
 * @param {number} max
 * @returns {string}
 */
function zero(value, max) {
    return (value > 0xff ? value.toString(16) : mapping[value]).padStart(max, '0');
}
/**
 * @function hex
 * @function Hex 查看器
 * @param {Uint8Array} buffer
 * @returns {string}
 */
function hex(buffer) {
    var length = buffer.length;
    var last = length % 16 || 16;
    var rows = Math.ceil(length / 16);
    var offsetLength = Math.max(6, length.toString(16).length);
    var rowBytes;
    var index = 0;
    var rowSpaces;
    var hex = "\u001B[36mOFFSET  ";
    for (var i = 0; i < 16; i++) {
        hex += " " + zero(i, 2);
    }
    hex += "\u001B[0m\n";
    if (length) {
        hex += "\n";
    }
    for (var i = 0; i < rows; i++) {
        hex += "\u001B[36m" + zero(index, offsetLength) + "\u001B[0m  ";
        rowBytes = i === rows - 1 ? last : 16;
        rowSpaces = 16 - rowBytes;
        for (var j = 0; j < rowBytes; j++) {
            hex += " " + zero(buffer[index++], 2);
        }
        for (var j = 0; j <= rowSpaces; j++) {
            hex += "   ";
        }
        index -= rowBytes;
        for (var j = 0; j < rowBytes; j++) {
            var byte = buffer[index++];
            hex += (byte > 31 && byte < 127) || byte > 159 ? String.fromCharCode(byte) : ".";
        }
        hex += "\n";
    }
    return hex.trim();
}

/*! *****************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */

function __awaiter(thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
}

function __generator(thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (_) try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [op[0] & 2, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
}

var wasm = "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AC8AYQByAHIAYQB5AC4AdABzAEH8DgsBLABBiA8LIwEAAAAcAAAASQBuAHYAYQBsAGkAZAAgAGwAZQBuAGcAdABoAEGsDwsBPABBuA8LLQEAAAAmAAAAfgBsAGkAYgAvAGEAcgByAGEAeQBiAHUAZgBmAGUAcgAuAHQAcwBB7A8LATwAQfgPCycBAAAAIAAAAH4AbABpAGIALwBkAGEAdABhAHYAaQBlAHcALgB0AHMAQawQCwE8AEG4EAspAQAAACIAAABhAHMAcwBlAG0AYgBsAHkALwBpAG4AZABlAHgALgB0AHMAQewQCwE8AEH4EAsrAQAAACQAAAB+AGwAaQBiAC8AdAB5AHAAZQBkAGEAcgByAGEAeQAuAHQAcwBBrBELAkwDAEG4EQu2BggAAAAwAwAA3wBTAFMAAABJAbwCTgAAAPABSgAMAwAAkAOZAwgDAQOwA6UDCAMBA4cFNQVSBQAAlh5IADEDAACXHlQACAMAAJgeVwAKAwAAmR5ZAAoDAACaHkEAvgIAAFAfpQMTAwAAUh+lAxMDAANUH6UDEwMBA1YfpQMTA0IDgB8IH5kDAACBHwkfmQMAAIIfCh+ZAwAAgx8LH5kDAACEHwwfmQMAAIUfDR+ZAwAAhh8OH5kDAACHHw8fmQMAAIgfCB+ZAwAAiR8JH5kDAACKHwofmQMAAIsfCx+ZAwAAjB8MH5kDAACNHw0fmQMAAI4fDh+ZAwAAjx8PH5kDAACQHygfmQMAAJEfKR+ZAwAAkh8qH5kDAACTHysfmQMAAJQfLB+ZAwAAlR8tH5kDAACWHy4fmQMAAJcfLx+ZAwAAmB8oH5kDAACZHykfmQMAAJofKh+ZAwAAmx8rH5kDAACcHywfmQMAAJ0fLR+ZAwAAnh8uH5kDAACfHy8fmQMAAKAfaB+ZAwAAoR9pH5kDAACiH2ofmQMAAKMfax+ZAwAApB9sH5kDAAClH20fmQMAAKYfbh+ZAwAApx9vH5kDAACoH2gfmQMAAKkfaR+ZAwAAqh9qH5kDAACrH2sfmQMAAKwfbB+ZAwAArR9tH5kDAACuH24fmQMAAK8fbx+ZAwAAsh+6H5kDAACzH5EDmQMAALQfhgOZAwAAth+RA0IDAAC3H5EDQgOZA7wfkQOZAwAAwh/KH5kDAADDH5cDmQMAAMQfiQOZAwAAxh+XA0IDAADHH5cDQgOZA8wflwOZAwAA0h+ZAwgDAAPTH5kDCAMBA9YfmQNCAwAA1x+ZAwgDQgPiH6UDCAMAA+MfpQMIAwED5B+hAxMDAADmH6UDQgMAAOcfpQMIA0ID8h/6H5kDAADzH6kDmQMAAPQfjwOZAwAA9h+pA0IDAAD3H6kDQgOZA/wfqQOZAwAAAPtGAEYAAAAB+0YASQAAAAL7RgBMAAAAA/tGAEYASQAE+0YARgBMAAX7UwBUAAAABvtTAFQAAAAT+0QFRgUAABT7RAU1BQAAFftEBTsFAAAW+04FRgUAABf7RAU9BQBB/BcLgAQHCAkKCwwGBgYGBgYGBgYGDQYGDgYGBgYGBgYGDxAREgYTBgYGBgYGBgYGBhQVBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGFhcGBgYYBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYZBgYGBhoGBgYGBgYGGwYGBgYGBgYGBgYGHAYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYdBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYeBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgBB6xwLFCQrKysrKysrKwEAVFZWVlZWVlZWAEGSHQufAxgAAAArKysrKysrBysrW1ZWVlZWVlZKVlYFMVAxUDFQMVAxUDFQMVAxUCRQeTFQMVAxOFAxUDFQMVAxUDFQMVAxUE4xAk4NDU4DTgAkbgBOMSZuUU4kUE45FIEbHR1TMVAxUA0xUDFQMVAbUyRQMQJce1x7XHtce1x7FHlce1x7XC0rSQNIA3hcexQAlgoBKygGBgAqBioqKwe7tSseACsHKysrASsrKysrKysrKysrKysrKysrKysrKysrKysrKysrKysrASsrKysrKysrKysrKysrKysrKysrKysrKisrKysrKysrKysrKyvNRs0rACUrBwEGAVVWVlZWVlVWVgIkgYGBgYEVgYGBAAArALLRstGy0bLRAADNzAEA19fX19eDgYGBgYGBgYGBgaysrKysrKysrKwcAAAAAAAxUDFQMVAxUDFQMQIAADFQMVAxUDFQMVAxUDFQMVAxUE4xUDFQTjFQMVAxUDFQMVAxUDFQMQKHpoemh6aHpoemh6aHpoemKisrKysrKysrKysrKwAAAFRWVlZWVlZWVlZWVlYAQY8hCyFUVlZWVlZWVlZWVlZWDAAMKisrKysrKysrKysrKysHKgEAQeUhC3cqKysrKysrKysrKysrKysrKysrKysrKysrKytWVmyBFQArKysrKysrKysrKysrKysrKysrKysrKysrKysrKysrKysrKysrKysrKysHbANBKytWVlZWVlZWVlZWVlZWVixWKysrKysrKysrKysrKysrKysrKysrAQBBhCMLCAxsAAAAAAAGAEGyIwvoAgYlBiUGJQYlBiUGJQYlBiUGJQYlBiUGJQYlBiUGJQYlBiUGJQYlBiUGJQYlBiUGJQYlVnqeJgYlBiUGJQYlBiUGJQYlBiUGJQYlBiUGJQYlBiUGJQYBKytPVlYsK39WVjkrK1VWVisrT1ZWLCt/VlaBN3Vbe1wrK09WVgKsBAAAOSsrVVZWKytPVlYsKytWVjITgVcAb4F+ydd+LYGBDn45f29XAIGBfhUAfgMrKysrKysrKysrKysHKyQrlysrKysrKysrKyorKysrK1ZWVlZWgIGBgYE5uyorKysrKysrKysrKysrKysrKysrKysrKysrKysrKysrKysrKysrKysrAYGBgYGBgYGBgYGBgYGBgcmsrKysrKysrKysrKysrKzQDQBOMQK0wcHX1yRQMVAxUDFQMVAxUDFQMVAxUDFQMVAxUDFQMVAxUDFQMVDX11PBR9TX19cFKysrKysrKysrKysrBwEAAQBB9SYLH04xUDFQMVAxUDFQMVAxUA0AAAAAACRQMVAxUDFQMVAAQbYnC1YrKysrKysrKysrK3lce1x7T3tce1x7XHtce1x7XHtce1x7XHtcLSsreRRce1wteSpcJ1x7XHtce6QACrRce1x7TwN4OCsrKysrKysrKysrKytPLSsrAQBBpygLAUgAQbEoCxsqKysrKysrKysrKysrKysrKysrKysrKysrKysAQe0oCxQrKysrKysrKwcASFZWVlZWVlZWAgBBuCkLGysrKysrKysrKysrKytVVlZWVlZWVlZWVlZWDgBB8ikLGiQrKysrKysrKysrKwcAVlZWVlZWVlZWVlZWAEG4KgsnJCsrKysrKysrKysrKysrKysHAAAAAFZWVlZWVlZWVlZWVlZWVlZWAEGZKwsWKisrKysrKysrKytWVlZWVlZWVlZWDgBBzysLFiorKysrKysrKysrVlZWVlZWVlZWVg4AQZAsCxcrKysrKysrKysrK1VWVlZWVlZWVlZWDgBB6SwLCAgAAFYBAAA5AEH4LAu8BwEgAAAA4P//AL8dAADnAgAAeQAAAiQAAAEBAAAA////AAAAAAECAAAA/v//ATn//wAY//8Bh///ANT+/wDDAAAB0gAAAc4AAAHNAAABTwAAAcoAAAHLAAABzwAAAGEAAAHTAAAB0QAAAKMAAAHVAAAAggAAAdYAAAHaAAAB2QAAAdsAAAA4AAADAAAAALH//wGf//8ByP//AigkAAAAAAABAQAAAP///wAz//8AJv//AX7//wErKgABXf//ASgqAAA/KgABPf//AUUAAAFHAAAAHyoAABwqAAAeKgAALv//ADL//wA2//8ANf//AE+lAABLpQAAMf//ACilAABEpQAAL///AC3//wD3KQAAQaUAAP0pAAAr//8AKv//AOcpAABDpQAAKqUAALv//wAn//8Auf//ACX//wAVpQAAEqUAAiRMAAAAAAABIAAAAOD//wEBAAAA////AFQAAAF0AAABJgAAASUAAAFAAAABPwAAANr//wDb//8A4f//AMD//wDB//8BCAAAAML//wDH//8A0f//AMr//wD4//8Aqv//ALD//wAHAAAAjP//AcT//wCg//8B+f//AhpwAAEBAAAA////ASAAAADg//8BUAAAAQ8AAADx//8AAAAAATAAAADQ//8BAQAAAP///wAAAAAAwAsAAWAcAAAAAAAB0JcAAQgAAAD4//8CBYoAAAAAAAFA9P8Anuf/AMKJAADb5/8Akuf/AJPn/wCc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";

// Runtime header offsets
const ID_OFFSET = -8;
const SIZE_OFFSET = -4;

// Runtime ids
const ARRAYBUFFER_ID = 0;
const STRING_ID = 1;
// const ARRAYBUFFERVIEW_ID = 2;

// Runtime type information
const ARRAYBUFFERVIEW = 1 << 0;
const ARRAY = 1 << 1;
const STATICARRAY = 1 << 2;
// const SET = 1 << 3;
// const MAP = 1 << 4;
const VAL_ALIGN_OFFSET = 6;
// const VAL_ALIGN = 1 << VAL_ALIGN_OFFSET;
const VAL_SIGNED = 1 << 11;
const VAL_FLOAT = 1 << 12;
// const VAL_NULLABLE = 1 << 13;
const VAL_MANAGED = 1 << 14;
// const KEY_ALIGN_OFFSET = 15;
// const KEY_ALIGN = 1 << KEY_ALIGN_OFFSET;
// const KEY_SIGNED = 1 << 20;
// const KEY_FLOAT = 1 << 21;
// const KEY_NULLABLE = 1 << 22;
// const KEY_MANAGED = 1 << 23;

// Array(BufferView) layout
const ARRAYBUFFERVIEW_BUFFER_OFFSET = 0;
const ARRAYBUFFERVIEW_DATASTART_OFFSET = 4;
const ARRAYBUFFERVIEW_DATALENGTH_OFFSET = 8;
const ARRAYBUFFERVIEW_SIZE = 12;
const ARRAY_LENGTH_OFFSET = 12;
const ARRAY_SIZE = 16;

const BIGINT = typeof BigUint64Array !== "undefined";
const THIS = Symbol();

const STRING_SMALLSIZE = 192; // break-even point in V8
const STRING_CHUNKSIZE = 1024; // mitigate stack overflow
const utf16 = new TextDecoder("utf-16le", { fatal: true }); // != wtf16

/** Gets a string from memory. */
function getStringImpl(buffer, ptr) {
  let len = new Uint32Array(buffer)[ptr + SIZE_OFFSET >>> 2] >>> 1;
  const wtf16 = new Uint16Array(buffer, ptr, len);
  if (len <= STRING_SMALLSIZE) return String.fromCharCode(...wtf16);
  try {
    return utf16.decode(wtf16);
  } catch {
    let str = "", off = 0;
    while (len - off > STRING_CHUNKSIZE) {
      str += String.fromCharCode(...wtf16.subarray(off, off += STRING_CHUNKSIZE));
    }
    return str + String.fromCharCode(...wtf16.subarray(off));
  }
}

/** Prepares the base module prior to instantiation. */
function preInstantiate(imports) {
  const extendedExports = {};

  function getString(memory, ptr) {
    if (!memory) return "<yet unknown>";
    return getStringImpl(memory.buffer, ptr);
  }

  // add common imports used by stdlib for convenience
  const env = (imports.env = imports.env || {});
  env.abort = env.abort || function abort(msg, file, line, colm) {
    const memory = extendedExports.memory || env.memory; // prefer exported, otherwise try imported
    throw Error(`abort: ${getString(memory, msg)} at ${getString(memory, file)}:${line}:${colm}`);
  };
  env.trace = env.trace || function trace(msg, n, ...args) {
    const memory = extendedExports.memory || env.memory;
    console.log(`trace: ${getString(memory, msg)}${n ? " " : ""}${args.slice(0, n).join(", ")}`);
  };
  env.seed = env.seed || Date.now;
  imports.Math = imports.Math || Math;
  imports.Date = imports.Date || Date;

  return extendedExports;
}

const E_NOEXPORTRUNTIME = "Operation requires compiling with --exportRuntime";
const F_NOEXPORTRUNTIME = function() { throw Error(E_NOEXPORTRUNTIME); };

/** Prepares the final module once instantiation is complete. */
function postInstantiate(extendedExports, instance) {
  const exports = instance.exports;
  const memory = exports.memory;
  const table = exports.table;
  const __new = exports.__new || F_NOEXPORTRUNTIME;
  const __pin = exports.__pin || F_NOEXPORTRUNTIME;
  const __unpin = exports.__unpin || F_NOEXPORTRUNTIME;
  const __collect = exports.__collect || F_NOEXPORTRUNTIME;
  const __rtti_base = exports.__rtti_base;
  const getRttiCount = __rtti_base
    ? function (arr) { return arr[__rtti_base >>> 2]; }
    : F_NOEXPORTRUNTIME;

  extendedExports.__new = __new;
  extendedExports.__pin = __pin;
  extendedExports.__unpin = __unpin;
  extendedExports.__collect = __collect;

  /** Gets the runtime type info for the given id. */
  function getInfo(id) {
    const U32 = new Uint32Array(memory.buffer);
    const count = getRttiCount(U32);
    if ((id >>>= 0) >= count) throw Error(`invalid id: ${id}`);
    return U32[(__rtti_base + 4 >>> 2) + id * 2];
  }

  /** Gets and validate runtime type info for the given id for array like objects */
  function getArrayInfo(id) {
    const info = getInfo(id);
    if (!(info & (ARRAYBUFFERVIEW | ARRAY | STATICARRAY))) throw Error(`not an array: ${id}, flags=${info}`);
    return info;
  }

  /** Gets the runtime base id for the given id. */
  function getBase(id) {
    const U32 = new Uint32Array(memory.buffer);
    const count = getRttiCount(U32);
    if ((id >>>= 0) >= count) throw Error(`invalid id: ${id}`);
    return U32[(__rtti_base + 4 >>> 2) + id * 2 + 1];
  }

  /** Gets the runtime alignment of a collection's values. */
  function getValueAlign(info) {
    return 31 - Math.clz32((info >>> VAL_ALIGN_OFFSET) & 31); // -1 if none
  }

  /** Gets the runtime alignment of a collection's keys. */
  // function getKeyAlign(info) {
  //   return 31 - Math.clz32((info >>> KEY_ALIGN_OFFSET) & 31); // -1 if none
  // }

  /** Allocates a new string in the module's memory and returns its pointer. */
  function __newString(str) {
    if (str == null) return 0;
    const length = str.length;
    const ptr = __new(length << 1, STRING_ID);
    const U16 = new Uint16Array(memory.buffer);
    for (var i = 0, p = ptr >>> 1; i < length; ++i) U16[p + i] = str.charCodeAt(i);
    return ptr;
  }

  extendedExports.__newString = __newString;

  /** Reads a string from the module's memory by its pointer. */
  function __getString(ptr) {
    if (!ptr) return null;
    const buffer = memory.buffer;
    const id = new Uint32Array(buffer)[ptr + ID_OFFSET >>> 2];
    if (id !== STRING_ID) throw Error(`not a string: ${ptr}`);
    return getStringImpl(buffer, ptr);
  }

  extendedExports.__getString = __getString;

  /** Gets the view matching the specified alignment, signedness and floatness. */
  function getView(alignLog2, signed, float) {
    const buffer = memory.buffer;
    if (float) {
      switch (alignLog2) {
        case 2: return new Float32Array(buffer);
        case 3: return new Float64Array(buffer);
      }
    } else {
      switch (alignLog2) {
        case 0: return new (signed ? Int8Array : Uint8Array)(buffer);
        case 1: return new (signed ? Int16Array : Uint16Array)(buffer);
        case 2: return new (signed ? Int32Array : Uint32Array)(buffer);
        case 3: return new (signed ? BigInt64Array : BigUint64Array)(buffer);
      }
    }
    throw Error(`unsupported align: ${alignLog2}`);
  }

  /** Allocates a new array in the module's memory and returns its pointer. */
  function __newArray(id, values) {
    const info = getArrayInfo(id);
    const align = getValueAlign(info);
    const length = values.length;
    const buf = __new(length << align, info & STATICARRAY ? id : ARRAYBUFFER_ID);
    let result;
    if (info & STATICARRAY) {
      result = buf;
    } else {
      __pin(buf);
      const arr = __new(info & ARRAY ? ARRAY_SIZE : ARRAYBUFFERVIEW_SIZE, id);
      __unpin(buf);
      const U32 = new Uint32Array(memory.buffer);
      U32[arr + ARRAYBUFFERVIEW_BUFFER_OFFSET >>> 2] = buf;
      U32[arr + ARRAYBUFFERVIEW_DATASTART_OFFSET >>> 2] = buf;
      U32[arr + ARRAYBUFFERVIEW_DATALENGTH_OFFSET >>> 2] = length << align;
      if (info & ARRAY) U32[arr + ARRAY_LENGTH_OFFSET >>> 2] = length;
      result = arr;
    }
    const view = getView(align, info & VAL_SIGNED, info & VAL_FLOAT);
    if (info & VAL_MANAGED) {
      for (let i = 0; i < length; ++i) {
        const value = values[i];
        view[(buf >>> align) + i] = value;
      }
    } else {
      view.set(values, buf >>> align);
    }
    return result;
  }

  extendedExports.__newArray = __newArray;

  /** Gets a live view on an array's values in the module's memory. Infers the array type from RTTI. */
  function __getArrayView(arr) {
    const U32 = new Uint32Array(memory.buffer);
    const id = U32[arr + ID_OFFSET >>> 2];
    const info = getArrayInfo(id);
    const align = getValueAlign(info);
    let buf = info & STATICARRAY
      ? arr
      : U32[arr + ARRAYBUFFERVIEW_DATASTART_OFFSET >>> 2];
    const length = info & ARRAY
      ? U32[arr + ARRAY_LENGTH_OFFSET >>> 2]
      : U32[buf + SIZE_OFFSET >>> 2] >>> align;
    return getView(align, info & VAL_SIGNED, info & VAL_FLOAT).subarray(buf >>>= align, buf + length);
  }

  extendedExports.__getArrayView = __getArrayView;

  /** Copies an array's values from the module's memory. Infers the array type from RTTI. */
  function __getArray(arr) {
    const input = __getArrayView(arr);
    const len = input.length;
    const out = new Array(len);
    for (let i = 0; i < len; i++) out[i] = input[i];
    return out;
  }

  extendedExports.__getArray = __getArray;

  /** Copies an ArrayBuffer's value from the module's memory. */
  function __getArrayBuffer(ptr) {
    const buffer = memory.buffer;
    const length = new Uint32Array(buffer)[ptr + SIZE_OFFSET >>> 2];
    return buffer.slice(ptr, ptr + length);
  }

  extendedExports.__getArrayBuffer = __getArrayBuffer;

  /** Copies a typed array's values from the module's memory. */
  function getTypedArray(Type, alignLog2, ptr) {
    return new Type(getTypedArrayView(Type, alignLog2, ptr));
  }

  /** Gets a live view on a typed array's values in the module's memory. */
  function getTypedArrayView(Type, alignLog2, ptr) {
    const buffer = memory.buffer;
    const U32 = new Uint32Array(buffer);
    const bufPtr = U32[ptr + ARRAYBUFFERVIEW_DATASTART_OFFSET >>> 2];
    return new Type(buffer, bufPtr, U32[bufPtr + SIZE_OFFSET >>> 2] >>> alignLog2);
  }

  /** Attach a set of get TypedArray and View functions to the exports. */
  function attachTypedArrayFunctions(ctor, name, align) {
    extendedExports[`__get${name}`] = getTypedArray.bind(null, ctor, align);
    extendedExports[`__get${name}View`] = getTypedArrayView.bind(null, ctor, align);
  }

  [
    Int8Array,
    Uint8Array,
    Uint8ClampedArray,
    Int16Array,
    Uint16Array,
    Int32Array,
    Uint32Array,
    Float32Array,
    Float64Array
  ].forEach(ctor => {
    attachTypedArrayFunctions(ctor, ctor.name, 31 - Math.clz32(ctor.BYTES_PER_ELEMENT));
  });

  if (BIGINT) {
    [BigUint64Array, BigInt64Array].forEach(ctor => {
      attachTypedArrayFunctions(ctor, ctor.name.slice(3), 3);
    });
  }

  /** Tests whether an object is an instance of the class represented by the specified base id. */
  function __instanceof(ptr, baseId) {
    const U32 = new Uint32Array(memory.buffer);
    let id = U32[ptr + ID_OFFSET >>> 2];
    if (id <= getRttiCount(U32)) {
      do {
        if (id == baseId) return true;
        id = getBase(id);
      } while (id);
    }
    return false;
  }

  extendedExports.__instanceof = __instanceof;

  // Pull basic exports to extendedExports so code in preInstantiate can use them
  extendedExports.memory = extendedExports.memory || memory;
  extendedExports.table  = extendedExports.table  || table;

  // Demangle exports and provide the usual utility on the prototype
  return demangle(exports, extendedExports);
}

function isResponse(src) {
  return typeof Response !== "undefined" && src instanceof Response;
}

function isModule(src) {
  return src instanceof WebAssembly.Module;
}

/** Asynchronously instantiates an AssemblyScript module from anything that can be instantiated. */
async function instantiate(source, imports = {}) {
  if (isResponse(source = await source)) return instantiateStreaming(source, imports);
  const module = isModule(source) ? source : await WebAssembly.compile(source);
  const extended = preInstantiate(imports);
  const instance = await WebAssembly.instantiate(module, imports);
  const exports = postInstantiate(extended, instance);
  return { module, instance, exports };
}

/** Asynchronously instantiates an AssemblyScript module from a response, i.e. as obtained by `fetch`. */
async function instantiateStreaming(source, imports = {}) {
  if (!WebAssembly.instantiateStreaming) {
    return instantiate(
      isResponse(source = await source)
        ? source.arrayBuffer()
        : source,
      imports
    );
  }
  const extended = preInstantiate(imports);
  const result = await WebAssembly.instantiateStreaming(source, imports);
  const exports = postInstantiate(extended, result.instance);
  return { ...result, exports };
}

/** Demangles an AssemblyScript module's exports to a friendly object structure. */
function demangle(exports, extendedExports = {}) {
  const setArgumentsLength = exports["__argumentsLength"]
    ? length => { exports["__argumentsLength"].value = length; }
    : exports["__setArgumentsLength"] || exports["__setargc"] || (() => { /* nop */ });
  for (let internalName in exports) {
    if (!Object.prototype.hasOwnProperty.call(exports, internalName)) continue;
    const elem = exports[internalName];
    let parts = internalName.split(".");
    let curr = extendedExports;
    while (parts.length > 1) {
      let part = parts.shift();
      if (!Object.prototype.hasOwnProperty.call(curr, part)) curr[part] = {};
      curr = curr[part];
    }
    let name = parts[0];
    let hash = name.indexOf("#");
    if (hash >= 0) {
      const className = name.substring(0, hash);
      const classElem = curr[className];
      if (typeof classElem === "undefined" || !classElem.prototype) {
        const ctor = function(...args) {
          return ctor.wrap(ctor.prototype.constructor(0, ...args));
        };
        ctor.prototype = {
          valueOf() { return this[THIS]; }
        };
        ctor.wrap = function(thisValue) {
          return Object.create(ctor.prototype, { [THIS]: { value: thisValue, writable: false } });
        };
        if (classElem) Object.getOwnPropertyNames(classElem).forEach(name =>
          Object.defineProperty(ctor, name, Object.getOwnPropertyDescriptor(classElem, name))
        );
        curr[className] = ctor;
      }
      name = name.substring(hash + 1);
      curr = curr[className].prototype;
      if (/^(get|set):/.test(name)) {
        if (!Object.prototype.hasOwnProperty.call(curr, name = name.substring(4))) {
          let getter = exports[internalName.replace("set:", "get:")];
          let setter = exports[internalName.replace("get:", "set:")];
          Object.defineProperty(curr, name, {
            get() { return getter(this[THIS]); },
            set(value) { setter(this[THIS], value); },
            enumerable: true
          });
        }
      } else {
        if (name === 'constructor') {
          (curr[name] = (...args) => {
            setArgumentsLength(args.length);
            return elem(...args);
          }).original = elem;
        } else { // instance method
          (curr[name] = function(...args) { // !
            setArgumentsLength(args.length);
            return elem(this[THIS], ...args);
          }).original = elem;
        }
      }
    } else {
      if (/^(get|set):/.test(name)) {
        if (!Object.prototype.hasOwnProperty.call(curr, name = name.substring(4))) {
          Object.defineProperty(curr, name, {
            get: exports[internalName.replace("set:", "get:")],
            set: exports[internalName.replace("get:", "set:")],
            enumerable: true
          });
        }
      } else if (typeof elem === "function" && elem !== setArgumentsLength) {
        (curr[name] = (...args) => {
          setArgumentsLength(args.length);
          return elem(...args);
        }).original = elem;
      } else {
        curr[name] = elem;
      }
    }
  }
  return extendedExports;
}

function readAssembly() {
    if (globalThis.atob) {
        var source = globalThis.atob(wasm);
        var sourceLength = source.length;
        var bytes = new Uint8Array(sourceLength);
        for (var i = 0; i < sourceLength; i++) {
            bytes[i] = source.charCodeAt(i);
        }
        return bytes.buffer;
    }
    else {
        return Buffer.from(wasm, 'base64');
    }
}
var buffer;
var Buffer$1 = {
    init: function () {
        return __awaiter(this, void 0, void 0, function () {
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        if (buffer)
                            return [2 /*return*/, buffer];
                        return [4 /*yield*/, instantiate(readAssembly())];
                    case 1: return [2 /*return*/, (buffer = (_a.sent()).exports)];
                }
            });
        });
    }
};

/**
 * @module tests
 */
Buffer$1.init().then(function (_a) {
    var Buffer = _a.Buffer, __getUint8Array = _a.__getUint8Array, __getString = _a.__getString, __newString = _a.__newString;
    /**
     * @function byteLength
     * @description 获取字符串指定编码字节长度
     * @param {string} input
     * @param {string} [encoding]
     * @returns {number}
     */
    function byteLength(input, encoding) {
        if (encoding === void 0) { encoding = 'UTF8'; }
        var buffer = new Buffer();
        buffer.write(__newString(input), __newString(encoding));
        return buffer.length;
    }
    var buffer = new Buffer();
    var desc = "A buffer tool using WebAssembly.";
    buffer.writeInt8(0xaf);
    buffer.writeUint8(0xfa);
    buffer.writeBoolean(0x01);
    buffer.writeInt16(0xfafc);
    buffer.writeUint16(0xfcfa);
    buffer.writeInt32(0xfafbfcfd);
    buffer.writeUint32(0xfdfbfafc);
    // @ts-ignore
    buffer.writeInt64(0xf0f1fafbfcfdfeffn);
    // @ts-ignore
    buffer.writeUint64(0xfffefdfcfbfaf1f0n);
    buffer.writeFloat32(123456.654321);
    buffer.writeFloat64(987654321.123456789);
    buffer.write(__newString(desc));
    console.log(hex(__getUint8Array(buffer.bytes)));
    buffer.offset = 0;
    console.log(0xaf, '->', buffer.readInt8());
    console.log(0xfa, '->', buffer.readUint8());
    console.log(0x01, '->', buffer.readBoolean());
    console.log(0xfafc, '->', buffer.readInt16());
    console.log(0xfcfa, '->', buffer.readUint16());
    console.log(0xfafbfcfd, '->', buffer.readInt32());
    console.log(0xfdfbfafc, '->', buffer.readUint32());
    // @ts-ignore
    console.log(0xf0f1fafbfcfdfeffn, '->', buffer.readInt64());
    // @ts-ignore
    console.log(0xfffefdfcfbfaf1f0n, '->', buffer.readUint64());
    console.log(123456.654321, '->', buffer.readFloat32());
    console.log(987654321.123456789, '->', buffer.readFloat64());
    console.log(desc, '->', __getString(buffer.read(byteLength(desc))));
    console.log(hex(__getUint8Array(buffer.bytes)));
});
